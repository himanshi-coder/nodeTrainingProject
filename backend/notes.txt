// dependencies explaination --

    "dependencies": {
        "bcrypt": "^5.1.1",
        "cookie-parser": "^1.4.7",
        "cors": "^2.8.5",
        "dotenv": "^16.4.5",
        "express": "^4.21.1",
        "jsonwebtoken": "^9.0.2",
        "nodemon": "^3.1.7",
        "pg": "^8.13.1", // PostgreSQL client for Node.js.
        "pg-hstore": "^2.3.4", // Serializer for handling PostgreSQL's JSON data type
        "sequelize": "^6.37.5" // Sequelize library,
        "nodemailer": "^6.9.16", // allows you to send emails
        "crypto": "^1.0.1", // for generating OTPs
    }


// we will get logs like this in the console

    Executing (default): SELECT 1+1 AS result

    Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
    PostgreSQL database connected!

    Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_Users_status' GROUP BY 1
    Executing (default): DO 'BEGIN CREATE TYPE "public"."enum_Users_status" AS ENUM(''0'', ''1''); EXCEPTION WHEN duplicate_object THEN null; END';
    Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
    Executing (default): CREATE TABLE IF NOT EXISTS "Users" ("id" UUID , "first_name" VARCHAR(255), "last_name" VARCHAR(255), "user_name" VARCHAR(255), "email" VARCHAR(255), "phone" VARCHAR(255), "role" VARCHAR(255), "password" VARCHAR(255), "access_token" VARCHAR(255), "remember_me" BOOLEAN, "status" "public"."enum_Users_status", "reset_password_token" VARCHAR(255), "created_at" TIMESTAMP WITH TIME ZONE, "updated_at" TIMESTAMP WITH TIME ZONE, "deleted_at" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id"));
    Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
    Database synced!

    // console logs meaning
        Database Connection Test
        Executing (default): SELECT 1+1 AS result
        PostgreSQL database connected!
            What happened?: Sequelize tested the connection to the PostgreSQL database by running a simple query (SELECT 1+1 AS result).
            Outcome: The connection was successful, and the message PostgreSQL database connected! confirms it.
            
        Checking Table Existence
        Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
            What happened?: Sequelize checked if the table Users exists in the public schema of your database.
            Why?: When using Sequelize models, it verifies the existence of tables to determine if they need to be created or modified.

what is node.js ?
    - node.js is an open source, server environment, which is event driven. it runs on single thread, non-blocking, asynchronous programming which is very memory efficient.

Api's ?
    - API - Application programming interface. it consists of various communication protocols

Sequelize ?
    - sequelize is a promise based node.js ORM tool. it is a modern typescript and node.js ORM for postgres, mysql, mariaDB, SQLite and SQL server. 

ORM (Object Relational Mapping) ?
    - ORM is a technique to accessing a relational database from an object-oriented language 
    - toll that maps software to database tables.


====================================================================
    sequelize (ORM) notes -
        Modal Basics - 
            - Modal represents a database table. we can define columns and there type into Modal. Usually modals have singular names (such as User) while tables have pluralized names (such as Users).
            - Modals can be defined in two ways in sequelize.
                - Calling - sequelize.define(modalName, attributes, options)
                - Extending Modal and calling - init(attributes, options)
        
                    1. Using sequelize.define
                        This method defines a model without extending the Sequelize Model class.
                        ----------------
                        const { Sequelize, DataTypes } = require('sequelize');
                        const sequelize = new Sequelize('database', 'username', 'password', {
                        host: 'localhost',
                        dialect: 'mysql', // or 'postgres', 'sqlite', 'mssql'
                        });

                        const User = sequelize.define(
                        'User', // Model name
                        {
                            // Attributes (columns)
                            id: {
                            type: DataTypes.INTEGER,
                            autoIncrement: true,
                            primaryKey: true,
                            },
                            name: {
                            type: DataTypes.STRING,
                            allowNull: false,
                            },
                            email: {
                            type: DataTypes.STRING,
                            unique: true,
                            allowNull: false,
                            },
                            password: {
                            type: DataTypes.STRING,
                            allowNull: false,
                            },
                        },
                        {
                            // Options
                            tableName: 'users', // Explicit table name if different from model name
                            timestamps: true, // Adds createdAt and updatedAt fields, it can be false as well 
                        }
                        );

                        module.exports = User;

                    2. Extending the Model Class and Using init
                        This method involves extending Sequelize's Model class and calling init to define the model.
                        --------------------
                        const { Sequelize, DataTypes, Model } = require('sequelize');
                        const sequelize = new Sequelize('database', 'username', 'password', {
                        host: 'localhost',
                        dialect: 'mysql', // or 'postgres', 'sqlite', 'mssql'
                        });

                        class User extends Model {}

                        User.init(
                        {
                            // Attributes (columns)
                            id: {
                            type: DataTypes.INTEGER,
                            autoIncrement: true,
                            primaryKey: true,
                            },
                            name: {
                            type: DataTypes.STRING,
                            allowNull: false,
                            },
                            email: {
                            type: DataTypes.STRING,
                            unique: true,
                            allowNull: false,
                            },
                            password: {
                            type: DataTypes.STRING,
                            allowNull: false,
                            },
                        },
                        {
                            // Options
                            sequelize, // Pass the Sequelize instance
                            modelName: 'User', // Model name
                            tableName: 'users', // Explicit table name
                            timestamps: true, // Adds createdAt and updatedAt fields, it can be false as well 
                        }
                        );

                        module.exports = User;
        ====================================================================
        Table synchronization
                - sync only one table (modal)
                    - User.sync() - This creates table if does not exist
                    - User.sync({force: true}) - This deletes table first and then creates the table, table will be re-created
                    - User.sync({alter: true}) - It performs the necessary changes in the table to make it match to the Modal, // Adjust schema without dropping tables

                - sync all modals at once
                    - sequelize.sync({force: true}) - all modals will be synchronize at once

                - during sync logs like these will be printed
                    // we will get logs like this in the console 

                        Executing (default): SELECT 1+1 AS result

                        Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
                        PostgreSQL database connected!

                        Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_Users_status' GROUP BY 1
                        Executing (default): DO 'BEGIN CREATE TYPE "public"."enum_Users_status" AS ENUM(''0'', ''1''); EXCEPTION WHEN duplicate_object THEN null; END';
                        Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
                        Executing (default): CREATE TABLE IF NOT EXISTS "Users" ("id" UUID , "first_name" VARCHAR(255), "last_name" VARCHAR(255), "user_name" VARCHAR(255), "email" VARCHAR(255), "phone" VARCHAR(255), "role" VARCHAR(255), "password" VARCHAR(255), "access_token" VARCHAR(255), "remember_me" BOOLEAN, "status" "public"."enum_Users_status", "reset_password_token" VARCHAR(255), "created_at" TIMESTAMP WITH TIME ZONE, "updated_at" TIMESTAMP WITH TIME ZONE, "deleted_at" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id"));
                        Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
                        Database synced!

                    // console logs meaning
                        Database Connection Test
                        Executing (default): SELECT 1+1 AS result
                        PostgreSQL database connected!
                            What happened?: Sequelize tested the connection to the PostgreSQL database by running a simple query (SELECT 1+1 AS result).
                            Outcome: The connection was successful, and the message PostgreSQL database connected! confirms it.
                            
                        Checking Table Existence
                        Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
                            What happened?: Sequelize checked if the table Users exists in the public schema of your database.
                            Why?: When using Sequelize models, it verifies the existence of tables to determine if they need to be created or modified.

                
                - Delete one table
                    - User.drop() // this will delete User table

                - Delete all the tables in the database
                    - sequelize.drop() // All tables deleted
        ====================================================================
        Table joins and associations - 
                we have three types of associations  (one-to-one, one-to-many, many-to-many) and to achieve these we have 4 methods (HasOne, BelongsTo, HasMany, BelongsToMany)
                - to create any association we need two things - in the related tables, those we want to join -       
                    // in the table we want data 
                    category_id: {
                        type: DataTypes.UUID,
                        allowNull: false,
                    },
                - one-to-one association (one contact can be associated with one user)
                    // for this we will use  HasOne and BelongsTo
                        - HasOne association - one user have one contact (one contact can be associated with one user) - Specifies that one record (ex. User_id) in Contact can have one related record in User.
                        - BelongsTo association
                        use of the methods-  // Associations // This adds a `userId` foreign key in the `Contact` table.
                                User.hasOne(Contact, { foreignKey: 'userId' }); // User has one Contact
                                Contact.belongsTo(User, { foreignKey: 'userId' }); // Contact belongs to one User
                                
                - one-to-many association (one user can be associated with multiple contacts) 
                    // for this we will use HasMany and BelongsTo associations
                - many-to-many association 
                    // for this we will use BelongsToMany association


                // examples for all the relationships 

                    In Sequelize, you can create different types of joins based on the relationships between the models: one-to-one, one-to-many, and many-to-many. Let’s go over how to define these associations and use them in queries.

                    1. One-to-One Relationship
                        A one-to-one relationship means that a single record in one table is associated with a single record in another table. For example, a User might have a Profile, where each User has exactly one Profile, and vice versa.

                        => Model Setup:

                            // User Model
                            User.hasOne(Profile, {
                                foreignKey: 'user_id',
                                as: 'profile', // Alias for easy reference
                            });

                            // Profile Model
                            Profile.belongsTo(User, {
                                foreignKey: 'user_id',
                                as: 'user', // Alias for easy reference
                            });
                            
                        => Fetching Data:
                            - Fetch a User with its Profile:

                                const userWithProfile = await User.findOne({
                                    where: { id: 'some-user-id' },
                                    include: [
                                        {
                                        model: Profile,
                                        as: 'profile', // Alias defined in association
                                        attributes: ['bio', 'avatar'],
                                        },
                                    ],
                                });

                                console.log(userWithProfile);
                            
                            - Fetch a Profile with its User:

                                const profileWithUser = await Profile.findOne({
                                    where: { profile_id: 'some-profile-id' },
                                    include: [
                                        {
                                        model: User,
                                        as: 'user', // Alias defined in association
                                        attributes: ['first_name', 'last_name'],
                                        },
                                    ],
                                });

                                console.log(profileWithUser);

                    2. One-to-Many Relationship
                        A one-to-many relationship means that one record in a table is associated with multiple records in another table. For example, a Category might have many Products.

                        => Model Setup:

                            // Category Model
                                Category.hasMany(Product, {
                                    foreignKey: 'category_id',
                                    as: 'products', // Alias for easy reference
                                });

                            // Product Model
                                Product.belongsTo(Category, {
                                    foreignKey: 'category_id',
                                    as: 'category', // Alias for easy reference
                                });

                        => Fetching Data:
                            - Fetch a Category with its Products:

                                const categoryWithProducts = await Category.findOne({
                                where: { category_id: 'some-category-id' },
                                    include: [
                                        {
                                        model: Product,
                                        as: 'products', // Alias defined in association
                                        attributes: ['product_name', 'price'],
                                        },
                                    ],
                                });

                                console.log(categoryWithProducts);

                            - Fetch a Product with its Category:

                                const productWithCategory = await Product.findOne({
                                    where: { product_id: 'some-product-id' },
                                        include: [
                                            {
                                            model: Category,
                                            as: 'category', // Alias defined in association
                                            attributes: ['name'],
                                            },
                                        ],
                                    });

                                console.log(productWithCategory);

                    3. Many-to-Many Relationship
                        A many-to-many relationship means that multiple records in one table are associated with multiple records in another table. For example, a User can have many Roles, and a Role can be assigned to many Users. This requires a join table to store the associations.

                        => Model Setup:
                            You already have a many-to-many relationship between Property and Amenity using a join table. Here’s how you can define another many-to-many relationship:

                                // User Model
                                    User.belongsToMany(Role, {
                                        through: 'UserRoles', // The join table
                                        foreignKey: 'user_id',
                                        otherKey: 'role_id',
                                        as: 'roles', // Alias for easy reference
                                    });

                                // Role Model
                                    Role.belongsToMany(User, {
                                        through: 'UserRoles', // The join table
                                        foreignKey: 'role_id',
                                        otherKey: 'user_id',
                                        as: 'users', // Alias for easy reference
                                    });

                        => Fetching Data:
                            - Fetch a User with its Roles:

                                const userWithRoles = await User.findOne({
                                    where: { id: 'some-user-id' },
                                        include: [
                                            {
                                            model: Role,
                                            as: 'roles', // Alias defined in association
                                            attributes: ['role_name'],
                                            through: { attributes: [] }, // Exclude join table data
                                            },
                                        ],
                                });

                            console.log(userWithRoles);

                            - Fetch a Role with its Users:

                                const roleWithUsers = await Role.findOne({
                                    where: { role_id: 'some-role-id' },
                                    include: [
                                        {
                                        model: User,
                                        as: 'users', // Alias defined in association
                                        attributes: ['first_name', 'last_name'],
                                        through: { attributes: [] }, // Exclude join table data
                                        },
                                    ],
                                });

                            console.log(roleWithUsers);

                    4. Using Aliases in Joins
                        In all the above examples, you can see that aliases (as) are used to define the relationship 
                        in a readable way. These aliases are used in the include option when querying the data 
                        to specify which related model to include.

                        Alias: as: 'roles' or as: 'profile' is used to refer to the association in a query, 
                        ensuring that the data is loaded correctly.

                    5. Excluding Join Table Data
                        In many-to-many relationships, the join table (like UserRoles in the above example) 
                        contains foreign keys that link the two models. If you don't want to include the join 
                        table data in your result, you can specify through: { attributes: [] } as shown in the 
                        many-to-many examples above.

                    Recap:
                        One-to-One: Use hasOne and belongsTo for direct relationships between two models 
                            (e.g., User has one Profile).
                        One-to-Many: Use hasMany and belongsTo to model a one-to-many relationship 
                            (e.g., Category has many Products).
                        Many-to-Many: Use belongsToMany with a through option to model a many-to-many relationship, 
                            typically requiring a join table (e.g., User belongs to many Roles via a UserRoles join table).
                            By defining your associations and using eager loading with include, you can easily perform 
                            joins in Sequelize, fetching related data in a single query.
                                    
        ====================================================================
        


=======================
Topics to study 

    1	Node.js Basics 	"What is Node.js: Understanding the event-driven, non-blocking I/O model.
    Modules: require, exports, CommonJS vs ES6 modules (import/export).
    Global Objects: _dirname, _filename, process, Buffer.
    NPM (Node Package Manager): Installing, updating, and managing dependencies. "

    2	Asynchronous Programming 	"Callbacks: Understanding callback functions and callback hell.
    Promises: Handling async operations with then() and catch().
    async/await: Simplified syntax for working with Promises.
    Event Loop: How Node.js handles asynchronous operations.
    Timers: setTimeout(), setInterval(), setImmediate().
    "
    3	HTTP Module 	"Creating HTTP Server: Basic server setup with http.createServer().
    Handling HTTP Requests/Responses: Reading data from requests and sending responses.
    Handling Routing and Query Parameters.
    Serving Static Files.
    "
    4	APIs and RESTful Services 	"Building REST APIs: Understanding CRUD operations (Create, Read, Update, Delete).
    Working with JSON: Sending and receiving JSON data.
    API Versioning: Structuring routes for versioning APIs.
    Authentication/Authorization: JWT (JSON Web Tokens), OAuth, Passport.js.
    Rate Limiting: Preventing abuse by limiting API requests.
    "
    5	Databases 	"NoSQL Databases: MongoDB with mongoose for schema-based models.
    SQL Databases: Using PostgreSQL or MySQL with sequelize, pg, or mysql drivers.
    Database Operations: CRUD operations, queries, joins (for SQL), and aggregation (for NoSQL).
    Connection Pools: Managing database connections efficiently.
    ORMs: Object Relational Mapping tools like Sequelize and Mongoose.
    "
    6	Authentication & Authorization 	"JWT (JSON Web Tokens): Stateless authentication method.
    Sessions and Cookies: Storing user sessions and managing cookies.
    "
    7	Error Handling	  "Synchronous vs Asynchronous Errors: Catching errors in callbacks, promises, and async/await.
    Global Error Handling: Setting up error-handling middleware in Express.
    Logging: Using console.log(), winston, or morgan for structured logging.
    Graceful Error Handling: Gracefully shutting down the server on critical failures. "
    8	Testing in Node.js 	"Unit Testing: Testing individual functions using frameworks like Mocha, Jest, or Jasmine.
    Integration Testing: Testing how different parts of the application work together.
    Mocking: Using sinon or jest for mocking objects and functions.
    Supertest: Testing HTTP APIs with the supertest library.
    "
    9	Deployment and Scaling 	"Environment Variables: Managing different environments (development, production) using .env and dotenv.
    PM2: Managing and scaling Node.js applications. "
    10	Node.js Best Practices 	"Project Structure: Organizing large-scale applications.
    Code Style and Linting: Using eslint, prettier for consistent code style.
    API Documentation: Using Swagger or Postman to document APIs.
    Version Control: Using Git effectively to manage code changes"

=======================
Questions for exam
    1. Node.js Basics
        1.1 What is Node.js, and how does its event-driven, non-blocking I/O model work?
        1.2 Explain the difference between CommonJS and ES6 modules. Provide examples of require vs. import.
        1.3 What are _dirname and _filename? How are they used?
        1.4 What is the process object in Node.js, and what are some of its key methods?
        1.5 How do you install, update, and remove dependencies using NPM?
        1.6 What is the purpose of the Buffer class in Node.js?

    2. Asynchronous Programming
        2.1 What is the Event Loop in Node.js? How does it handle asynchronous operations?
        2.2 Explain callback functions and provide an example of callback hell.
        2.3 How do Promises work in Node.js? What are then() and catch() used for?
        2.4 Rewrite a callback-based function using Promises.
        2.5 What is the purpose of async/await, and how does it simplify working with Promises?
        2.6 Explain the difference between setTimeout, setInterval, and setImmediate.

    3. HTTP Module
        3.1 How do you create a basic HTTP server in Node.js? Provide an example.
        3.2 How can you handle incoming HTTP requests and send responses?
        3.3 What are query parameters, and how can you handle them in a Node.js HTTP server?
        3.4 Write a code snippet to serve static files using the http module.
        3.5 Explain the difference between GET, POST, PUT, DELETE methods in HTTP.

    4. APIs and RESTful Services
        What are the core principles of REST APIs?
        Write an example of a basic CRUD operation using a REST API in Node.js.
        How do you handle API versioning in a Node.js application?
        What is JWT, and how is it used in authentication?
        Explain the concept of rate limiting and how to implement it in an API.
        How do you send and receive JSON data in a Node.js application?

    5. Databases
        What is the difference between SQL and NoSQL databases? Provide examples.
        Explain how to perform CRUD operations in MongoDB using Mongoose.
        Write an example of querying a SQL database using Sequelize.
        What are connection pools, and why are they important?
        Explain the concept of aggregation in MongoDB with an example.
        What is ORM? How does Sequelize or Mongoose simplify database operations?

    6. Authentication & Authorization
        What is the difference between sessions and JWT for authentication?
        Write an example of implementing user authentication using JWT in Node.js.
        How do cookies work in managing user sessions?
        Explain the difference between authentication and authorization.

    7. Error Handling
        What is the difference between synchronous and asynchronous errors? Provide examples.
        How can you handle errors in a Promise chain?
        What is error-handling middleware in Express? Write a basic example.
        How do you log errors in Node.js using libraries like Winston or Morgan?
        What steps would you take to gracefully shut down a server in the event of a critical failure?

    8. Testing in Node.js
        What is the difference between unit testing and integration testing?
        Write a unit test for a simple function using Jest.
        How do you mock dependencies using Sinon or Jest?
        Write an integration test for a REST API using Supertest.
        Why is testing important in Node.js applications?

    9. Deployment and Scaling
        How do you manage environment variables in a Node.js application?
        Explain the role of PM2 in deploying and scaling Node.js applications.
        Write a basic ecosystem.config.js file for PM2 deployment.
        What is the importance of .env files, and how do you load them using the dotenv library?

    10. Node.js Best Practices
        How would you structure a large-scale Node.js application?
        Why is it important to use linters like ESLint or Prettier?
        What is API documentation, and how do Swagger and Postman help with it?
        How do you manage code versions using Git? Provide examples of common Git commands.
        What are some best practices for error handling in Node.js applications?

================================

Questions with explainations
    :::::::::::
    1.1 What is Node.js, and how does its event-driven, non-blocking I/O model work?
        Event-Driven, Non-Blocking I/O Model
        1. Event-Driven Architecture
            Node.js relies on an event-driven model, where an event loop listens for and processes events, such as HTTP requests, file reads, or database queries.

            Events are triggered as tasks are completed or as specific conditions are met (e.g., receiving data from a file read).
            A corresponding callback function is executed when the event occurs.
            Example:

            ----------
                const fs = require('fs');

                // Reading a file asynchronously
                fs.readFile('example.txt', 'utf-8', (err, data) => {
                    if (err) {
                        console.error('Error reading file:', err);
                        return;
                    }
                    console.log('File content:', data);
                });

                console.log('File reading initiated...');

                Output:
                    File reading initiated...
                    File content: [file data]
                    Notice that the file reading does not block the execution of the next line of code.
            -------

        2. Non-Blocking (I/O - input/output operations)
            Node.js uses non-blocking input/output operations, which means that tasks like reading files, querying databases, or making network requests are performed asynchronously without blocking the execution of other tasks.

            Blocking I/O: The program waits until the current task finishes before moving to the next.
            Non-Blocking I/O: The program moves to the next task immediately and executes the I/O operation in the background.
                Example:
                    const http = require('http');

                    // Creating an HTTP server
                    const server = http.createServer((req, res) => {
                        res.end('Hello, world!');
                    });

                    // Server listens on port 3000
                    server.listen(3000, () => {
                        console.log('Server is running on port 3000...');
                    });
            The listen function is non-blocking, allowing the server to handle multiple requests simultaneously.

        3. Event Loop
            The event loop is a core mechanism in Node.js that enables non-blocking behavior. It continuously checks for events or tasks in different phases, such as:
                Timers (setTimeout, setInterval)
                Pending I/O operations
                Callbacks
                Closures and Promises
            The event loop ensures that operations are handled one at a time, even in an asynchronous environment.

            Advantages of the Model:
                High Performance: Efficiently handles thousands of concurrent requests.
                Scalability: Ideal for real-time applications like chat apps and online gaming.
                Asynchronous Programming: No waiting for I/O operations to complete.
            
            Use Case Examples
                Real-Time Applications: Chat servers, live streaming, or collaborative tools.
                API Backends: Handling multiple HTTP requests efficiently.
                File Operations: Reading/writing files without blocking other operations.
    :::::::::::
    1.2 Explain the difference between CommonJS and ES6 modules. Provide examples of require vs. import.
        
        Difference Between CommonJS and ES6 Modules
            Node.js and JavaScript use modules to encapsulate code into reusable units. CommonJS and ES6 are two different module systems used in JavaScript:

        CommonJS Modules
            Introduction: CommonJS is the default module system used in Node.js (pre-ES6).
            Usage: Modules are imported using require() and exported using module.exports or exports.
            Synchronous Loading: Modules are loaded synchronously, meaning the file is read and executed immediately.
            Platform Support: Works natively in Node.js but not directly in browsers without tools like Webpack or Browserify.
            Exports Type: CommonJS modules export an object.

            Example:

                // math.js (CommonJS module)
                function add(a, b) {
                    return a + b;
                }
                function subtract(a, b) {
                    return a - b;
                }

                // Export functions
                module.exports = { add, subtract };

                // main.js
                const math = require('./math'); // Importing the module
                console.log(math.add(5, 3)); // Output: 8
                console.log(math.subtract(5, 3)); // Output: 2

        ES6 Modules
            Introduction: Introduced in ECMAScript 2015 (ES6), ES6 modules are the standard for JavaScript.
            Usage: Modules are imported using import and exported using export.
            Asynchronous Loading: Modules are loaded asynchronously, making them suitable for modern web development.
            Platform Support: Supported natively in modern browsers and in Node.js (from version 12+) with the .mjs extension or "type": "module" in package.json.
            Exports Type: ES6 modules export individual bindings.

            Example:

                // math.mjs (ES6 module)
                export function add(a, b) {
                    return a + b;
                }
                export function subtract(a, b) {
                    return a - b;
                }

                // main.mjs
                import { add, subtract } from './math.mjs'; // Import specific functions
                console.log(add(5, 3)); // Output: 8
                console.log(subtract(5, 3)); // Output: 2

        Key Differences
            Feature         | CommonJS	                    | ES6 Modules
            -------------------------------------------------------------------------------------------
            Syntax	        | require()                     | and module.exports	import and export
            -------------------------------------------------------------------------------------------
            Loading	        | Synchronous	                | Asynchronous
            -------------------------------------------------------------------------------------------
            Default         | Export	                    | Exports a single object	Can export individual bindings or a default export
            -------------------------------------------------------------------------------------------
            Browser         | Support	                    | Not natively supported	Natively supported in modern browsers
            -------------------------------------------------------------------------------------------
            Dynamic         | Import Possible via require()	| Use import() for dynamic loading
            -------------------------------------------------------------------------------------------
            File Extension  |.js	                        | .mjs or .js with "type": "module"
            -------------------------------------------------------------------------------------------
        
        Dynamic Import
            CommonJS:
                const moduleName = './math';
                const math = require(moduleName);
            ES6:
                const moduleName = './math.mjs';
                import(moduleName).then((math) => {
                    console.log(math.add(5, 3));
                });

        When to Use Each
            CommonJS: Use for older Node.js versions or when working on a Node.js-only project without modern tooling.
            ES6 Modules: Use for modern projects, especially those targeting browsers or Node.js environments with "type": "module" enabled.
    :::::::::::
    1.3 What are __dirname and __filename in Node.js? How are they used?
        
            __dirname and __filename are global variables in Node.js that provide useful information about the paths of the current module:

            1. __dirname
                Represents the directory name of the current module.
                It gives the absolute path of the folder containing the file being executed.
                Always points to the directory where the script resides, regardless of the current working directory.
            
            2. __filename
                Represents the file name of the current module.
                It gives the absolute path of the file being executed.
                Includes the full path of the script file, along with its name.

            Use Cases
                Building Paths Dynamically
                Since paths can vary based on the environment, using __dirname and __filename ensures platform-independent and absolute paths.

                Serving Static Files
                These variables are often used in web servers to serve static files like HTML, CSS, and JavaScript.

                File System Operations
                They are used in conjunction with Node.js's fs module to work with files and directories.

            Examples
                Using __dirname
                    const path = require('path');

                    // Log the directory of the current module
                    console.log(__dirname);

                    // Join `__dirname` with another path to create an absolute path
                    const filePath = path.join(__dirname, 'example.txt');
                    console.log(filePath);

                    Output:
                        /home/user/project
                        /home/user/project/example.txt

                Using __filename
                    // Log the full path of the current module
                    console.log(__filename);
                    Output:
                        /home/user/project/app.js

                Difference Between __dirname and process.cwd()
                    __dirname:
                        Always resolves to the directory where the script resides.
                    process.cwd():
                        Resolves to the current working directory where the Node.js process was started.
                        Example:
                            console.log(__dirname);  // e.g., /home/user/project
                            console.log(process.cwd()); // e.g., /home/user
                    Using __dirname to Serve Static Files
                        In a web server setup, you might use __dirname to create an absolute path for serving static files.

                        Example:
                            const http = require('http');
                            const fs = require('fs');
                            const path = require('path');

                            http.createServer((req, res) => {
                                const filePath = path.join(__dirname, 'public', 'index.html');
                                fs.readFile(filePath, (err, data) => {
                                    if (err) {
                                        res.writeHead(500);
                                        res.end('Error loading file');
                                        return;
                                    }
                                    res.writeHead(200, { 'Content-Type': 'text/html' });
                                    res.end(data);
                                });
                            }).listen(3000, () => {
                                console.log('Server running on http://localhost:3000');
                            });
            
            Key Points
                __dirname and __filename provide absolute paths for the current module.
                They are essential for file system operations and dynamic path management.
                Unlike relative paths (./), these variables ensure paths remain consistent regardless of the execution environment.
    :::::::::::
    1.4 What is the process object in Node.js, and what are some of its key methods?
        The process object in Node.js is a global object that provides information and control over the current Node.js process.
        It allows interaction with the operating system, environment, and the command-line arguments passed during execution.

        Key Features of process
            No need to import it (it's globally available).
            Provides methods and properties for:
            Managing environment variables.
            Exiting or killing the process.
            Listening for events like signals (SIGINT, SIGTERM).
            Accessing command-line arguments.

        Some Key Methods of process

            1. process.argv
                Returns an array containing the command-line arguments passed to the Node.js script.
                The first two elements are:
                    process.argv[0]: Path to the Node.js binary.
                    process.argv[1]: Path to the script being executed.

                Example:
                console.log(process.argv);
                // Running: `node script.js hello`
                // Output: [ '/usr/bin/node', '/path/to/script.js', 'hello' ]

            2. process.env
                Provides access to environment variables as an object.

                Example:
                    console.log(process.env.PATH);
                    process.env.MY_VARIABLE = 'custom_value';
                    console.log(process.env.MY_VARIABLE); // Output: custom_value

            3. process.exit([code])
                Terminates the Node.js process.
                code is an optional exit code (0 for success, non-zero for failure).
                Example:
                    if (!process.env.REQUIRED_ENV) {
                        console.error('Missing required environment variable!');
                        process.exit(1); // Exit with an error code
                    }

            4. process.cwd()
                Returns the current working directory of the process.
                Example:
                    console.log(`Current working directory: ${process.cwd()}`);

            5. process.on(event, callback)
                Attaches event listeners to process events like exit, SIGINT, uncaughtException.
                Example:
                    process.on('exit', (code) => {
                        console.log(`Process exited with code: ${code}`);
                    });

            6. process.memoryUsage()
                Returns an object with information about the memory usage of the Node.js process.
                Example:
                    console.log(process.memoryUsage());
                        /*
                        Output:
                            {
                            rss: 35000320, // Resident Set Size
                            heapTotal: 18227200,
                            heapUsed: 9980128,
                            external: 872072
                            }
                        */

            7. process.uptime()
                Returns the number of seconds the Node.js process has been running.
                Example:
                    console.log(`Uptime: ${process.uptime()} seconds`);

            8. process.stdin, process.stdout, and process.stderr
                process.stdin: For reading input from the terminal.
                process.stdout: For writing output to the terminal.
                process.stderr: For writing error messages.
                Example:
                    process.stdin.on('data', (data) => {
                        console.log(`Input: ${data.toString()}`);
                    });

                    process.stdout.write('Hello, world!\n');

        Key Properties of process
            Property	        | Description
            ----------------------------------------------------------------
            process.pid	        | The process ID of the Node.js process.
            process.version	    | Node.js version (e.g., v16.15.0).
            process.platform	| Operating system platform (win32, linux).
            process.arch	    | CPU architecture (x64, arm).
            process.hrtime()	| High-resolution timer for measuring execution times.

            Example: Combining Methods
                console.log(`Node.js version: ${process.version}`);
                console.log(`Platform: ${process.platform}`);
                console.log(`CPU Architecture: ${process.arch}`);

                process.on('SIGINT', () => {
                    console.log('Caught interrupt signal');
                    process.exit(0); // Graceful shutdown
                });

                setTimeout(() => {
                    console.log('Exiting after 5 seconds...');
                    process.exit(0);
                }, 5000);
        
        Summary
                The process object is central to managing and interacting with a Node.js application. By leveraging its methods and properties, developers can handle system-level functionality like environment variables, command-line arguments, process lifecycle, and memory usage effectively.
    :::::::::::
    1.5 How do you install, update, and remove dependencies using NPM?
        Action	Command
                Install a package	        | npm install <package-name>
            ----------------------------------------------------------
                Install globally	        | npm install -g <package-name>
            ----------------------------------------------------------
                Update a package	        | npm update <package-name>
            ----------------------------------------------------------
                Update all packages	        | npm update
            ----------------------------------------------------------
                Remove a package	        | npm uninstall <package-name>
            ----------------------------------------------------------
                Remove globally	            | npm uninstall -g <package-name>
            ----------------------------------------------------------
                Check outdated packages	    | npm outdated
            ----------------------------------------------------------
                Install all dependencies	| npm install
            ----------------------------------------------------------
                Audit dependencies	        | npm audit / npm audit fix
            ---------------------------------------------------------- 

        types of dependencies in package.json:

            Type	            Flag	    Use Case
            -------------------------------------------------------------
            Dependencies	    Default	    Required for the app to run.
            DevDependencies	    --save-dev	Only needed during development or testing.
            PeerDependencies	None	    Specify compatible dependencies required by consumers.

            Example:
                "dependencies": {
                "express": "^4.17.1"
                },
                "devDependencies": {
                "jest": "^29.0.0"
                },
                "peerDependencies": {
                "react": "^16.0.0"
                }

        Specifying Version Ranges
            You can specify version ranges when installing or updating packages:
                npm install <package-name>@x.y.z: Installs a specific version.
                npm install <package-name>@^x.y.z: Allows minor and patch updates.
                npm install <package-name>@~x.y.z: Allows only patch updates.

            You can install packages from Git repositories, tarballs, or local paths.
                npm install <git-repo-url>
                npm install https://github.com/expressjs/express

            Globally installed packages: npm list -g
        
        Managing Cache
            Clear NPM Cache: npm cache clean --force
        
        npx is used to execute packages without globally installing them.
    :::::::::::
    1.6 What is the purpose of the Buffer class in Node.js?
        The Buffer class in Node.js is used to handle binary data directly, particularly useful when dealing with streams of data or operations that involve file systems, networking, or cryptographic tasks. Buffers allow Node.js to interact with raw data, which is represented in the form of a sequence of bytes.

        Purpose of the Buffer Class
            Binary Data Handling: Provides an efficient way to manage and manipulate raw binary data.
            Stream Data Management: Used in streams to process chunks of data, like reading files or handling network requests.
            Encoding and Decoding: Supports data encoding and decoding, such as converting between UTF-8, Base64, and binary formats.
            Low-Level I/O Operations: Facilitates interaction with file systems, sockets, or other I/O interfaces that require byte-level manipulation.

        How to Create Buffers
            Using Buffer.alloc(): Allocates a buffer with specified size, initialized to zero.
                const buf = Buffer.alloc(5); // Allocates 5 bytes
                console.log(buf); // <Buffer 00 00 00 00 00>

            Using Buffer.from(): Creates a buffer from a given value (e.g., string, array).
                const buf = Buffer.from('Hello');
                console.log(buf); // <Buffer 48 65 6c 6c 6f>
        
            Using Buffer.allocUnsafe(): Allocates uninitialized memory (faster but potentially insecure).
                const buf = Buffer.allocUnsafe(5);
                console.log(buf); // Uninitialized memory

        Common Buffer Operations
            Writing Data into a Buffer:
                const buf = Buffer.alloc(10);
                buf.write('Node');
                console.log(buf.toString()); // 'Node'

            Reading Data from a Buffer:
                const buf = Buffer.from('Node.js');
                console.log(buf.toString('utf8')); // 'Node.js'

            Concatenating Buffers:
                const buf1 = Buffer.from('Hello, ');
                const buf2 = Buffer.from('World!');
                const buf3 = Buffer.concat([buf1, buf2]);
                console.log(buf3.toString()); // 'Hello, World!'

            Comparing Buffers:
                const buf1 = Buffer.from('abc');
                const buf2 = Buffer.from('xyz');
                console.log(buf1.compare(buf2)); // -1 (buf1 is less than buf2)

            Slicing a Buffer:
                const buf = Buffer.from('Node.js');
                const slicedBuf = buf.slice(0, 4);
                console.log(slicedBuf.toString()); // 'Node'

            Converting Buffer to JSON:
                const buf = Buffer.from('Node.js');
                console.log(buf.toJSON());
                // { type: 'Buffer', data: [ 78, 111, 100, 101, 46, 106, 115 ] }

        When to Use the Buffer Class
            File System Operations: For reading and writing binary files.
                const fs = require('fs');
                const buf = fs.readFileSync('file.txt');
                console.log(buf.toString());

            Stream Data Processing: Handles chunks of data in streams (e.g., network requests).

            Encoding and Decoding: Converts between encodings for cryptographic or data exchange purposes.

            Custom Protocols: For working with non-JSON, binary-based protocols.

            Example: Encoding and Decoding
                const buf = Buffer.from('Hello, World!');
                console.log(buf.toString('hex')); // Hexadecimal encoding
                console.log(buf.toString('base64')); // Base64 encoding

        Advantages of the Buffer Class
            Low-level access to binary data.
            Highly efficient for processing large data streams.
            Supports multiple encoding formats.
    :::::::::::
    2.1 What is the Event Loop in Node.js? How does it handle asynchronous operations?
        The Event Loop is the core mechanism in Node.js that enables non-blocking, asynchronous operations. It allows Node.js to perform I/O operations (like reading files, handling network requests) without blocking the execution of other code.
        Node.js is single-threaded, but thanks to the event loop, it can handle multiple operations concurrently by delegating tasks to the system kernel or worker threads and processing the results asynchronously.

        How the Event Loop Works
            The event loop continuously monitors the call stack and event queue. Here's a breakdown of how it works:

            Call Stack:

                Contains functions that are currently being executed.
                When the main program runs, its functions are pushed onto the call stack and executed synchronously.
        
            Event Queue:

                Holds callback functions waiting to be executed.
                These callbacks are added by asynchronous operations (like setTimeout, I/O operations, etc.).
        
            Event Loop Mechanism:

                Continuously checks if the call stack is empty.
                If the stack is empty, it pushes the first callback from the event queue to the stack for execution.
        
        Phases of the Event Loop
            The event loop operates in phases. Each phase handles a specific type of operation:

            Timers Phase:

                Executes callbacks from setTimeout() and setInterval() if their scheduled time has elapsed.
        
            Pending Callbacks Phase:

                Executes I/O callbacks that were deferred.
        
            Idle, Prepare Phase:

                Internal use only (used by Node.js internals).
            
            Poll Phase:

                Retrieves new I/O events.
                Executes I/O-related callbacks (e.g., reading files, receiving data from a network).
            
            Check Phase:

                Executes callbacks from setImmediate().
        
            Close Callbacks Phase:

                Handles cleanup and close events (e.g., socket.close()).
                
        How the Event Loop Handles Asynchronous Operations

            Timers:
                setTimeout and setInterval schedule callbacks to run after a specified time.
                    console.log('Before timeout');
                    setTimeout(() => {
                    console.log('Timeout callback');
                    }, 1000);
                    console.log('After timeout');
                    // Output:
                    // Before timeout
                    // After timeout
                    // Timeout callback
        
            Promises:
                Promises and async/await callbacks are handled in the microtask queue, which takes precedence over the event queue.
                    console.log('Start');
                    Promise.resolve().then(() => console.log('Promise resolved'));
                    console.log('End');
                    // Output:
                    // Start
                    // End
                    // Promise resolved

            I/O Operations:
                I/O tasks (like reading files) are delegated to the system kernel or worker threads.
                Once completed, the callbacks are added to the event queue.
                
                    const fs = require('fs');
                    console.log('Start');
                    fs.readFile('example.txt', (err, data) => {
                    if (err) throw err;
                        console.log('File read complete');
                    });
                    console.log('End');
                    // Output:
                        // Start
                        // End
                        // File read complete

            setImmediate:

                Executes its callbacks in the check phase, after I/O callbacks and before timers.
            
                setImmediate(() => console.log('setImmediate callback'));
                setTimeout(() => console.log('setTimeout callback'), 0);
                // Output:
                    // setTimeout callback
                    // setImmediate callback

        Visualization of the Event Loop
       
            Call Stack      | Event Queue         | Microtask Queue
            --------------------------------------------------------------
            [main()]        | [I/O callbacks]     | [Promise callbacks]
                            | [Timers]
                            | [setImmediate]

        Summary of the Event Loop's Role
            Manages and coordinates asynchronous operations.
            Ensures non-blocking behavior by delegating tasks to the kernel or worker threads.
            Executes callbacks in a predictable, phased manner.
            Handles both macro-tasks (e.g., I/O callbacks) and micro-tasks (e.g., Promises).
            Understanding the event loop is crucial for writing efficient, scalable, and non-blocking Node.js applications.
    :::::::::::
    2.2 Explain callback functions and provide an example of callback hell.
    :::::::::::
    
    :::::::::::
    3.1 How do you create a basic HTTP server in Node.js? Provide an example.
        Creating a Basic HTTP Server in Node.js
            The http module in Node.js allows you to create a basic HTTP server that can handle incoming requests and send responses. Here's how you can create and run an HTTP server:

        Steps to Create a Basic HTTP Server
            Import the http Module: Use the built-in http module to create the server.
            Create the Server: Use the http.createServer() method. This method takes a callback function with two parameters:
            request: Contains information about the incoming HTTP request.
            response: Used to send back data to the client.
            Listen on a Port: Use the server.listen(port) method to make the server listen for incoming requests on a specific port.

            Example Code
                const http = require('http');

                const server = http.createServer((req, res) => {
                if (req.url === '/' && req.method === 'GET') {
                    res.writeHead(200, { 'Content-Type': 'text/plain' });
                    res.end('Welcome to the Home Page!');
                } else if (req.url === '/about' && req.method === 'GET') {
                    res.writeHead(200, { 'Content-Type': 'text/plain' });
                    res.end('About Us Page');
                } else {
                    res.writeHead(404, { 'Content-Type': 'text/plain' });
                    res.end('404 Not Found');
                }
                });

                const PORT = 3000;
                server.listen(PORT, () => {
                console.log(`Server is running on http://localhost:${PORT}`);
                });
    :::::::::::
    3.2 How can you handle incoming HTTP requests and send responses?
        You can handle different HTTP methods (e.g., GET, POST, PUT, DELETE) by checking the req.method property.
            sending text as an response 
                ---------------
                    const http = require('http');

                    const server = http.createServer((req, res) => {
                    // Handle GET request
                    if (req.method === 'GET') {
                        res.statusCode = 200;
                        res.setHeader('Content-Type', 'text/plain');
                        res.end('You made a GET request');
                    }
                    
                    // Handle POST request
                    else if (req.method === 'POST') {
                        let body = '';
                        
                        // Read data from the request body
                        req.on('data', chunk => {
                        body += chunk;
                        });

                        req.on('end', () => {
                        res.statusCode = 200;
                        res.setHeader('Content-Type', 'application/json');
                        res.end(`You made a POST request with data: ${body}`);
                        });
                    }
                    
                    // Handle other HTTP methods
                    else {
                        res.statusCode = 405; // Method Not Allowed
                        res.setHeader('Content-Type', 'text/plain');
                        res.end('Method Not Allowed');
                    }
                    });

                    server.listen(3000, () => {
                    console.log('Server running at http://localhost:3000/');
                    });
                -----------------
                Explanation of the HTTP Method Handling Example:
                    req.method === 'GET': This checks the HTTP method of the incoming request. If it's a GET request, the server responds with a simple text message.

                    req.on('data', chunk => {...}): When handling a POST request, the data sent by the client is received in chunks. These chunks are combined into a full body of the request.

                    req.on('end', () => {...}): Once all chunks have been received, the server sends a response, including the data sent by the client.

            Sending JSON Response
                If you want to send a JSON response, you can use the JSON.stringify() method to convert an object to a JSON string.
                    -------------------------------------------------
                        const http = require('http');

                        const server = http.createServer((req, res) => {
                        if (req.method === 'GET') {
                            res.statusCode = 200;
                            res.setHeader('Content-Type', 'application/json');
                            const responseObject = { message: 'Hello, World!', status: 'success' };
                            res.end(JSON.stringify(responseObject)); // Send JSON response
                        } else {
                            res.statusCode = 405; // Method Not Allowed
                            res.setHeader('Content-Type', 'text/plain');
                            res.end('Method Not Allowed');
                        }
                        });

                        server.listen(3000, () => {
                        console.log('Server running at http://localhost:3000/');
                        });
                    ------------------------------------------------

            Serving Static Files
                To serve static files, like HTML, CSS, or JavaScript, you can use the fs module to read files and then send them in the response.
                    -------------------------------------------------------
                        const http = require('http');
                        const fs = require('fs');
                        const path = require('path');

                        const server = http.createServer((req, res) => {
                            const filePath = path.join(__dirname, 'index.html'); // Path to the static file

                            // Read the file and send it in the response
                            fs.readFile(filePath, (err, data) => {
                                if (err) {
                                    res.statusCode = 500;
                                    res.setHeader('Content-Type', 'text/plain');
                                    res.end('Error reading file');
                                } else {
                                    res.statusCode = 200;
                                    res.setHeader('Content-Type', 'text/html');
                                    res.end(data); // Send the file content
                                }
                            });
                        });

                        server.listen(3000, () => {
                            console.log('Server running at http://localhost:3000/');
                        });
                    -------------------------------------------------------

            Working with Image File
                To accept image uploads in a Node.js application, you can use middleware to handle the file parsing and storage. The most commonly used module for this task is multer, which is a Node.js middleware for handling multipart/form-data (used for uploading files).

                Steps to Accept Image Uploads Using multer:
                    Install multer: Install multer via npm:
                        npm install multer

                    Set Up Multer Middleware:
                        multer will handle the image upload and provide details about the uploaded file (e.g., file path, original name).
                        You can configure multer to save the uploaded image to a specific folder and set limits for file size and file types.
                    
                    Set Up Express Server:
                        Create an Express app that uses multer to accept image uploads.
                        
                    Example: Accepting Image Uploads with Multer
                        1. Create a Server to Handle Image Upload
                            const express = require('express');
                            const multer = require('multer');
                            const path = require('path');

                            const app = express();

                            // Set up multer storage options
                            const storage = multer.diskStorage({
                            destination: function (req, file, cb) {
                                // Set the directory where files will be uploaded
                                cb(null, './uploads');
                            },
                            filename: function (req, file, cb) {
                                // Save the file with its original name
                                cb(null, Date.now() + path.extname(file.originalname)); // e.g., 1638480548834.jpg
                            }
                            });

                            // Create the upload instance and specify file size limit (in bytes)
                            const upload = multer({
                            storage: storage,
                            limits: { fileSize: 5 * 1024 * 1024 }, // 5 MB file size limit
                            fileFilter: function (req, file, cb) {
                                // Accept only image files
                                const filetypes = /jpeg|jpg|png|gif/;
                                const extname = filetypes.test(path.extname(file.originalname).toLowerCase());
                                const mimetype = filetypes.test(file.mimetype);
                                
                                if (extname && mimetype) {
                                return cb(null, true);
                                } else {
                                cb(new Error('Invalid file type. Only images are allowed.'));
                                }
                            }
                            }).single('image'); // 'image' is the field name for the file in the form

                            // Handle POST request to upload image
                            app.post('/upload', (req, res) => {
                            upload(req, res, (err) => {
                                if (err) {
                                // If there's an error during upload (e.g., invalid file type or size exceeded)
                                return res.status(400).send(err.message);
                                }
                                // If upload is successful, send response with file details
                                res.status(200).send({
                                message: 'File uploaded successfully',
                                file: req.file
                                });
                            });
                            });

                            // Start the server
                            app.listen(3000, () => {
                            console.log('Server is running on http://localhost:3000');
                            });

                        2. Explanation of the Code:
                            multer.diskStorage(): This method defines how and where to store uploaded files. In this case, we specify the uploads folder as the destination and use the current timestamp as the filename to avoid name conflicts.

                            upload.single('image'): This middleware accepts a single image file uploaded via the image field. The field name must match the one used in the HTML form or client-side request.

                            File Size and Type Validation: In the multer configuration:
                                We limit the file size to 5MB (fileSize: 5 * 1024 * 1024).
                                We use a file filter to allow only image files (JPEG, PNG, GIF).
                                req.file: After the file is uploaded successfully, multer will attach the file metadata (like file path and name) to the req.file object.
    :::::::::::
    3.3 What are query parameters, and how can you handle them in a Node.js HTTP server?
        


=================================
env for ref 
    secretKey = nodeJsTrainingProjectSecretKey # --> this key is used to create jwt token and verify token
    SENDER_EMAIL = geetapanwar521@gmail.com # --> this id is used to generate otp emails for email verification
    SENDER_EMAIL_PASS = btce fesa fbkx rahm # --> this is app password for the email id this is created with the google accound -> app password
    # MAILER_SEND = mlsn.78232983c5185a9da0cecd1e4ae37cc0a7fcc9cd68dcb99e42d4a4e836b1e9ad 
    # mlsn.78232983c5185a9da0cecd1e4ae37cc0a7fcc9cd68dcb99e42d4a4e836b1e9ad
    # nodetrainingotpverifyuser
    # MAILER_SEND_SERVER = smtp.mailersend.net
    # MAILER_SEND_PORT = 587
    # MAILER_SEND_USERNAME = MS_6vYBG0@trial-351ndgweprngzqx8.mlsender.net
    # MAILER_SEND_PASSWORD = tY7McCOOby4FW7iC